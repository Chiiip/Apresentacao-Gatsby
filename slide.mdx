import { CodeSurfer } from "mdx-deck-code-surfer";

# React

## 16.3 - 16.7(alpha)

---

# Contexto

## (nÃ£o a API de contexto, contexto mesmo, tipo contextualizar)

---

# React 16.0, Fiber, async rendering

---

<img src={require("file-loader!./assets/stack_reconciliation.png")}/>
<p style={{ fontSize: "0.6em"}}>(Stack reconciliationâ€Šâ€”â€ŠÃ© preciso terminar a atualizaÃ§Ã£o antes de retornar para a main thread (crÃ©dito: Lin Clark))</p>
---
<img src={require("file-loader!./assets/fiber_reconciliation.png")}/>
<p style={{ fontSize: "0.6em"}}>(Fiber reconciliationâ€Šâ€”â€Šas atualizaÃ§Ãµes serÃ£o feitas em pedaÃ§os (crÃ©dito: Lin Clark))</p>
---
import { TwitterTweetEmbed } from "react-twitter-embed";

<TwitterTweetEmbed tweetId={"909926793536094209"} />

```notes
Aqui Ã© possÃ­vel verificar como o circulo de loading no canto superior direito para de ser renderizado enquanto a Ã rvore de componentes Ã© montada
```

---

# React 16.3

---

<CodeSurfer
  title="Context API"
  code={require("!raw-loader!./samples/contextApi.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    { lines: [1], notes: "Cria o contexto" },
    { range: [3, 13], notes: "Exemplo de componente que fornece contexto" },
    { range: [8, 10], notes: "Provider" },
    { range: [15, 23], notes: "Exemplo de componente que consome contexto" },
    { range: [18, 20], notes: "Consumer" },
    { range: [25, 31], notes: "Exemplo de uso" },
    { range: [27, 29], notes: "O consumidor deve estar abaixo de um provider na Ã¡rvore" },
  ]}
/>
---
<CodeSurfer
  title="createRef"
  code={require("!raw-loader!./samples/createRef.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    { range: [3, 28], notes: "AtÃ© entÃ£o, para se consumir referÃªncias a elementos da DOM ou outros componentes React, usava-se callback refs" },
    { lines: [19], notes: "Nele, a propriedade ref espera uma funÃ§Ã£o que recebe a referÃªncia ou null (quando se desmonta o componente)" },
    { range: [30, 55], notes: "O createRef Ã© uma nova API que simplifica o acesso a referÃªncias" },
    { lines: [32], notes: "Para usar, se cria um objeto Ref de antemÃ£o" },
    { lines: [46], notes: "O objeto Ã© passado pra propriedade ref" },
    { range: [36, 38], notes: "E a referÃªncia pode ser acessada na propriedade current do objeto Ref" }
  ]}
/>
---
<CodeSurfer
  title="fowardRef"
  code={require("!raw-loader!./samples/forwardRef.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    { lines: [3], notes: "forwardRef recebe um componente funcional e passa para ele um `ref` como segundo argumento"},
    { lines: [4], notes: "Esse ref pode ser passado para outros componentes, React ou nativos"},
    { range: [21, 27], notes: "O componente pode ser usado normalmente" },
    { lines: [4], notes: "Mas o conteÃºdo do `ref` serÃ¡ o <input/>, jÃ¡ que ele recebeu o `ref` de forwardRef" },
    { lines: [13], notes: "O que permite que se dÃª foco ao <input/> ðŸŽ‰" },
  ]}
/>
---
# Novos lifecycles
<img src={require("file-loader!./assets/lifecycle.jpg")}/>
---
# Strict Mode
---
# React 16.4
---
# Pointer Events
```notes
Pointer events are DOM events that are fired for a pointing device. They are designed to create a single DOM event model to handle pointing input devices such as a mouse, pen/stylus or touch (such as one or more fingers).
```
---
# "Bugfix" para getDerivedStateFromProps
```notes
getDerivedStateFromProps is now called every time a component is rendered, regardless of the cause of the update. Previously, it was only called if the component was re-rendered by its parent, and would not fire as the result of a local setState. This was an oversight in the initial implementation that has now been corrected. The previous behavior was more similar to componentWillReceiveProps, but the improved behavior ensures compatibility with Reactâ€™s upcoming asynchronous rendering mode.
```
---
# React 16.5
---
# Profiler
<img src={require("file-loader!./assets/profiler.png")}/>
---
# React 16.6
---
# React.memo
<CodeSurfer
  title="React.memo"
  code={require("!raw-loader!./samples/memo.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    { range: [1, 5], notes: "Como Ã© em classes" },
    { range: [7, 9], notes: "E agora a nova feature para funÃ§Ãµes..." },
  ]}
/>
```notes
Class components can bail out from rendering when their input props are the same using PureComponent or shouldComponentUpdate. Now you can do the same with function components by wrapping them in React.memo.
```
---
<CodeSurfer
  title="Code-Splitting Suspense"
  code={require("!raw-loader!./samples/code-splitting-suspense.jsx")}
  showNumbers={false}
  dark={false}
/>
---
<CodeSurfer
  title="ContextType"
  code={require("!raw-loader!./samples/static-context-type.jsx")}
  showNumbers={false}
  dark={false}
  steps={[
    {},
    { lines: [1], notes: "InstÃ¢ncia do contexto" },
    { lines: [4], notes: "AtribuiÃ§Ã£o do contexto" },
    { lines: [6], notes: "Consultando contexto" },
  ]}
/>

```notes
Weâ€™ve heard feedback that adopting the new render prop API can be difficult in class components. So weâ€™ve add a convenience API to consume a context value from within a class component.
```

---

# React 16.7 (alpha)

---

# Hooks

---

# O Problema

---

# A SoluÃ§Ã£o

---

# Concurrent React

---

# Time-slicing

---

# Suspense
